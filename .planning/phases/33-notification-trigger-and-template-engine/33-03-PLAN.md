---
phase: 33-notification-trigger-and-template-engine
plan: 03
type: execute
wave: 2
depends_on: ["33-01", "33-02"]
files_modified:
  - includes/services/class-notification-handler.php
  - includes/services/class-shipment-service.php
autonomous: true

must_haves:
  truths:
    - "買家收到出貨 LINE 通知（透過 NotificationService）"
    - "僅買家收到通知，賣家和小幫手不收到"
    - "同一張出貨單不會重複發送通知"
    - "通知失敗不影響出貨流程"
  artifacts:
    - path: "includes/services/class-notification-handler.php"
      provides: "完整的通知發送邏輯，包含 idempotency 檢查"
      contains: "send_shipment_notification"
    - path: "includes/services/class-shipment-service.php"
      provides: "出貨單服務，新增 notification_sent_at 欄位更新"
      contains: "notification_sent_at"
  key_links:
    - from: "includes/services/class-notification-handler.php"
      to: "includes/services/class-notification-service.php"
      via: "NotificationService::sendText()"
      pattern: "NotificationService::sendText"
    - from: "includes/services/class-notification-handler.php"
      to: "includes/services/class-notification-templates.php"
      via: "NotificationTemplates::format_* 方法"
      pattern: "NotificationTemplates::format_"
---

<objective>
完成出貨通知發送邏輯，實作 idempotency 機制防止重複發送，並整合 NotificationService 發送 LINE 通知給買家。

Purpose: 這是 Phase 33 的最終整合，將 Plan 01（觸發架構）和 Plan 02（模板引擎）串聯起來，實現完整的出貨通知流程。重點是確保僅通知買家、不重複發送、失敗不影響出貨。

Output:
- NotificationHandler 完整的通知發送邏輯
- Idempotency 機制（notification_sent_at 欄位檢查）
- Soft dependency 整合 buygo-line-notify
</objective>

<execution_context>
@/Users/fishtv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fishtv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/33-notification-trigger-and-template-engine/33-01-SUMMARY.md
@.planning/phases/33-notification-trigger-and-template-engine/33-02-SUMMARY.md
@includes/services/class-notification-handler.php
@includes/services/class-notification-service.php
@includes/services/class-notification-templates.php
@includes/services/class-shipment-service.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 實作 idempotency 檢查機制</name>
  <files>includes/services/class-notification-handler.php</files>
  <action>
修改 NotificationHandler，新增 idempotency 檢查邏輯，使用 shipped_at 欄位作為通知已發送的判斷依據。

設計決策：使用現有的 shipped_at 欄位而非新增 notification_sent_at 欄位，因為：
1. 出貨通知應該在標記出貨時發送一次
2. shipped_at 有值 = 已出貨 = 已發送通知（邏輯等價）
3. 減少資料庫變更成本

但考慮到未來可能需要區分「已出貨」和「已發送通知」，我們採用另一個方案：
使用 WordPress post meta 或自訂 meta 來記錄通知狀態。

最終方案：在 handle_shipment_marked_shipped() 中：
1. 先檢查出貨單 status 是否為 'shipped'（確保是標記出貨的事件）
2. 使用 get_transient() 檢查是否在短時間內（5 分鐘）已處理過此 shipment_id
3. 發送成功後設置 transient，避免重複發送

實作細節：
```php
private function is_notification_already_sent(int $shipment_id): bool {
    $transient_key = 'buygo_shipment_notified_' . $shipment_id;
    return get_transient($transient_key) !== false;
}

private function mark_notification_sent(int $shipment_id): void {
    $transient_key = 'buygo_shipment_notified_' . $shipment_id;
    set_transient($transient_key, time(), 5 * MINUTE_IN_SECONDS);
}
```

為什麼使用 transient 而非資料庫欄位：
- 出貨通知只發送一次，transient 5 分鐘足夠防止重複觸發
- 避免資料庫 schema 變更
- 效能更好（記憶體/Redis 快取）
  </action>
  <verify>
1. grep 檢查方法存在：
   ```bash
   grep -n "is_notification_already_sent" includes/services/class-notification-handler.php
   grep -n "mark_notification_sent" includes/services/class-notification-handler.php
   ```
2. grep 檢查 transient 使用：`grep -n "transient" includes/services/class-notification-handler.php`
3. PHP 語法檢查：`php -l includes/services/class-notification-handler.php`
  </verify>
  <done>
is_notification_already_sent() 和 mark_notification_sent() 方法已實作，使用 WordPress transient 防止重複發送
  </done>
</task>

<task type="auto">
  <name>Task 2: 整合 NotificationService 發送通知給買家</name>
  <files>includes/services/class-notification-handler.php</files>
  <action>
完成 NotificationHandler::send_shipment_notification() 方法，整合模板引擎和通知服務。

完整的發送流程：
```php
public function send_shipment_notification(int $shipment_id): void {
    // 1. Idempotency 檢查
    if ($this->is_notification_already_sent($shipment_id)) {
        $this->debug_service->log('NotificationHandler', '通知已發送，跳過', [
            'shipment_id' => $shipment_id
        ]);
        return;
    }

    try {
        // 2. 收集出貨單資料
        $shipment_data = $this->collect_shipment_data($shipment_id);
        if (!$shipment_data) {
            return;
        }

        // 3. 取得買家 WordPress User ID
        $customer_id = $shipment_data['customer_id'];

        // 4. 檢查買家是否有 LINE 綁定
        if (!IdentityService::hasLineBinding($customer_id)) {
            $this->debug_service->log('NotificationHandler', '買家未綁定 LINE，跳過通知', [
                'shipment_id' => $shipment_id,
                'customer_id' => $customer_id
            ]);
            return;
        }

        // 5. 準備模板變數
        $template_args = [
            'product_list' => NotificationTemplates::format_product_list($shipment_data['items']),
            'shipping_method' => NotificationTemplates::format_shipping_method($shipment_data['shipping_method']),
            'estimated_delivery' => NotificationTemplates::format_estimated_delivery($shipment_data['estimated_delivery_at'])
        ];

        // 6. 發送通知（僅發給買家，不發給賣家和小幫手）
        $result = NotificationService::sendText($customer_id, 'shipment_shipped', $template_args);

        if ($result) {
            // 7. 標記通知已發送
            $this->mark_notification_sent($shipment_id);
            $this->debug_service->log('NotificationHandler', '出貨通知發送成功', [
                'shipment_id' => $shipment_id,
                'customer_id' => $customer_id
            ]);
        } else {
            $this->debug_service->log('NotificationHandler', '出貨通知發送失敗', [
                'shipment_id' => $shipment_id,
                'customer_id' => $customer_id
            ], 'error');
        }

    } catch (\Exception $e) {
        // 確保通知失敗不影響出貨流程
        $this->debug_service->log('NotificationHandler', '出貨通知異常', [
            'shipment_id' => $shipment_id,
            'error' => $e->getMessage()
        ], 'error');
    }
}
```

關鍵設計：
- 只發給買家（customer_id），不發給賣家和小幫手
- 使用 try-catch 確保失敗不影響出貨
- 使用 DebugService 完整記錄流程
- 整合 IdentityService 檢查 LINE 綁定
  </action>
  <verify>
1. grep 檢查方法完整性：
   ```bash
   grep -n "send_shipment_notification" includes/services/class-notification-handler.php
   grep -n "collect_shipment_data" includes/services/class-notification-handler.php
   grep -n "NotificationService::sendText" includes/services/class-notification-handler.php
   ```
2. grep 檢查模板引擎整合：`grep -n "NotificationTemplates::format_" includes/services/class-notification-handler.php`
3. grep 檢查 try-catch：`grep -n "try\|catch" includes/services/class-notification-handler.php`
4. PHP 語法檢查：`php -l includes/services/class-notification-handler.php`
  </verify>
  <done>
send_shipment_notification() 方法完整實作，整合 idempotency、模板引擎、NotificationService，並確保僅通知買家
  </done>
</task>

<task type="auto">
  <name>Task 3: 完善 collect_shipment_data() 方法</name>
  <files>includes/services/class-notification-handler.php</files>
  <action>
完善 collect_shipment_data() 方法，確保收集所有通知所需的資料。

收集資料包含：
1. 出貨單基本資訊（shipment_id, shipment_number, customer_id, seller_id）
2. 出貨單商品明細（product_name, quantity）
3. 物流方式（從訂單或使用預設值）
4. 預計送達時間（estimated_delivery_at）

```php
private function collect_shipment_data(int $shipment_id): ?array {
    global $wpdb;

    // 1. 取得出貨單基本資料
    $shipment = $wpdb->get_row($wpdb->prepare(
        "SELECT * FROM {$wpdb->prefix}buygo_shipments WHERE id = %d AND status = 'shipped'",
        $shipment_id
    ), ARRAY_A);

    if (!$shipment) {
        $this->debug_service->log('NotificationHandler', '出貨單不存在或狀態不是 shipped', [
            'shipment_id' => $shipment_id
        ], 'warning');
        return null;
    }

    // 2. 取得出貨單商品明細（JOIN 產品資料取得商品名稱）
    $items = $wpdb->get_results($wpdb->prepare(
        "SELECT
            si.product_id,
            si.quantity,
            COALESCE(p.title, '未知商品') as product_name
         FROM {$wpdb->prefix}buygo_shipment_items si
         LEFT JOIN {$wpdb->prefix}fct_products p ON si.product_id = p.id
         WHERE si.shipment_id = %d",
        $shipment_id
    ), ARRAY_A);

    // 3. 取得物流方式（從第一筆關聯訂單）
    $shipping_method = null;
    $first_order_id = $wpdb->get_var($wpdb->prepare(
        "SELECT order_id FROM {$wpdb->prefix}buygo_shipment_items WHERE shipment_id = %d LIMIT 1",
        $shipment_id
    ));

    if ($first_order_id) {
        // 嘗試從訂單取得物流方式
        $shipping_method = $wpdb->get_var($wpdb->prepare(
            "SELECT shipping_method FROM {$wpdb->prefix}fct_orders WHERE id = %d",
            $first_order_id
        ));
    }

    return [
        'shipment_id' => $shipment['id'],
        'shipment_number' => $shipment['shipment_number'],
        'customer_id' => (int) $shipment['customer_id'],
        'seller_id' => (int) $shipment['seller_id'],
        'items' => $items ?: [],
        'shipping_method' => $shipping_method,
        'estimated_delivery_at' => $shipment['estimated_delivery_at'] ?? null,
        'shipped_at' => $shipment['shipped_at']
    ];
}
```

注意事項：
- 使用 LEFT JOIN 確保即使產品被刪除也能取得商品數量
- estimated_delivery_at 可能為 NULL（Phase 32 新增的欄位）
- 使用 COALESCE 處理產品名稱為 NULL 的情況
  </action>
  <verify>
1. grep 檢查方法實作：
   ```bash
   grep -A50 "function collect_shipment_data" includes/services/class-notification-handler.php
   ```
2. grep 檢查 JOIN 查詢：`grep -n "LEFT JOIN\|buygo_shipment_items" includes/services/class-notification-handler.php`
3. grep 檢查欄位存取：`grep -n "estimated_delivery_at\|shipping_method" includes/services/class-notification-handler.php`
4. PHP 語法檢查：`php -l includes/services/class-notification-handler.php`
  </verify>
  <done>
collect_shipment_data() 方法完整實作，正確收集出貨單資訊、商品明細、物流方式和預計送達時間
  </done>
</task>

</tasks>

<verification>
執行以下驗證確認計畫完成：

1. **完整流程驗證**
   ```bash
   # 檢查關鍵方法都存在
   grep -E "function (is_notification_already_sent|mark_notification_sent|send_shipment_notification|collect_shipment_data)" includes/services/class-notification-handler.php
   ```

2. **Idempotency 機制驗證**
   ```bash
   # 確認使用 transient
   grep -n "get_transient\|set_transient" includes/services/class-notification-handler.php
   ```

3. **通知服務整合驗證**
   ```bash
   # 確認呼叫 NotificationService
   grep -n "NotificationService::sendText" includes/services/class-notification-handler.php

   # 確認使用模板格式化方法
   grep -n "NotificationTemplates::format_" includes/services/class-notification-handler.php
   ```

4. **錯誤處理驗證**
   ```bash
   # 確認有 try-catch
   grep -c "try\|catch" includes/services/class-notification-handler.php
   ```

5. **PHP 語法驗證**
   ```bash
   php -l includes/services/class-notification-handler.php
   php -l includes/services/class-notification-templates.php
   ```
</verification>

<success_criteria>
1. NotificationHandler 包含完整的 send_shipment_notification() 方法
2. Idempotency 機制使用 transient 防止重複發送
3. 只發送通知給買家（customer_id），不發給賣家和小幫手
4. 整合 NotificationTemplates 格式化方法（format_product_list, format_shipping_method, format_estimated_delivery）
5. 整合 NotificationService::sendText() 發送 LINE 通知
6. collect_shipment_data() 正確收集所有必要資料
7. 使用 try-catch 確保通知失敗不影響出貨流程
8. 所有 PHP 檔案通過語法檢查
</success_criteria>

<output>
完成後建立 `.planning/phases/33-notification-trigger-and-template-engine/33-03-SUMMARY.md`
</output>
